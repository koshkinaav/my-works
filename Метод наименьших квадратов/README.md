# Домашнее задание № 2
## Метод наименьших квадратов

В файле [ccd.fits](https://disk.yandex.ru/d/d_mW1PFXnA8V9w) приведены данные эксперимента с приёмником изображений на основе [прибора с зарядовой связью](https://ru.wikipedia.org/wiki/%D0%9F%D0%97%D0%A1) (детектор [Sony ICX424](https://s1-dl.theimagingsource.com/api/2.5/packages/publications/sensors-ccd/icx424al/e6f6a6dc-f966-5bf2-89ca-b1370715d416/icx424al_1.2.en_US.pdf)). В указанном файле расположен четырёхмерный массив данных, содержащий 100 пар изображений, каждое размером 659x493 пикселей. Каждая пара представляет из себя изображения, полученные с детектора, равномерно засвеченного с различными интенсивностями (всего 100 вариантов, внутри пары интенсивность одинаковая). Первая по порядку пара — результат мгновенного считывания, и представляет из себя сигнал детектора в отсутствии света.

Используя простые рассуждения, можно показать, что из таких данных возможно получить оценки _шума считывания_ (_read out noise_) и _коэффициента усиления_ (_gain_). Напомним, что каждый пиксель детектора накапливает заряд, производимый за счёт внутреннего фотоэлектрического эффекта. После оцифровки величина сигнала выражается в условных _цифровых единицах_ (ADU), которые и записаны в файле, и связана с изначальным числом электронов следующим соотношением:

![цифровые единицы](.eqs/eq1.png)

где `g` — _коэффициент усиления_ измеряемый в \[![электрон](.eqs/e-.png) / ADU\], а дисперсия величины

![дисперсия](.eqs/eq2.png)

где ![sigma_r](.eqs/sigma_r.png) — _шум считывания_, для удобства измеряется в количестве ![электрон](.eqs/e-.png), а последний переход — следствие того, что для количества фотоотсчетов действует закон распределения Пуассона, и ![дисперсия распределения Пуассона](.eqs/eq4.png).

На практике удобнее рассматривать поэлементную разность значений пикселей внутри пары кадров, тогда

![дисперсия разности](.eqs/eq3.png)

где оценку ![sigma_Delta_x](.eqs/sigma_Delta_x.png) можно получить с помощью выборочной дисперсии по всем пикселям поэлементной разности кадров пары, а оценку `x` можно получить с помощью выборочного среднего по всем пикселям двух кадров пары. При этом для первой пары (в отсутствии света) средний сигнал будет ненулевой, он соответствует _напряжению смещения_, и не обусловлен световым потоком; поэтому полученную для первой пары величину следует вычесть из всех полученных оценок. Подробности доступны в [1].

[1]: Steve B. Howell, "Handbook of CCD Astronomy", Cambridge University Press, 2006

**Дедлайн 24 февраля 2022 в 23:55**

Вы должны сделать следующее:

 - В модуле `lsp` реализуйте функцию `lstsq_ne(a, b)` реализующую подход линейных наименьших квадратов с использованием нормальных уравнений. `a` — матрица задачи размера `(N, M)`, `b` — вектор задачи размера `(N,)`.
Функция должна возвращать кортеж `(x, cost, var)`, где `x` — решение задачи наименьших квадратов размера `(M,)`, `cost` — квадрат нормы вектора невязок размера, `var` — матрица ошибок решения размера `(N,N)`.

 - В модуле `lsp` реализуйте функцию `lstsq_svd(a, b, rcond=None)` реализующую подход линейных наименьших квадратов с использованием вычислений на основ алгоритма сингулярного разложения. Результат работы функции и смысл параметров совпадают с определением функции `lsqsq_ne`. Параметр `rcond` принимает необязательный аргумент для регуляризации, если аргумент задан, то все сингулярные числа меньше чем `rcond * s_max` должны игнорироваться.

 - В модуле `lsp` реализуйте функцию `lstsq(a, b, method, **kwargs)`, которая принимает дополнительный параметр `method` с возможными значениями `ne` или `svd` и возвращает результат работы одной из двух соответствующих функций. С помощью аргумента `kwargs` должна быть реализована передача специфичных для каждого из алгоритмов параметров.

 - В файле `eval.py`:
    * сгенерируйте случайную матрицу `A` размера 500x20, а так же вектор случайный вектор параметров `x` размера 20. Сгенерируйте 10000 реализаций случайного вектора `b` (размера 500) с многомерным нормальным распределением со средним `Ax` и диагональной матрицей ковариации с дисперсией 0.01;
    * используя метод наименьших квадратов (функцию `lstsq`, реализованную в предыдущем упражнении), получите 10000 оценок неизвестных параметров `x` задачи МНК с матрицей `A` и правой частью `b`, убедитесь, что величины невязки распределены в соответствии с распределением "Хи-квадрат" с соответствующим числом степеней свободы и масштабом;
    * изобразите на графике `chi2.png` частотную гистограмму величины невязки и теоретическое распределение. Для этого удобно использовать функцию `chi2.pdf` из пакета `scipy.stats`.

 - В файле `ccd.py`:
    * загрузите файл `ccd.fits` и вычислите оценки ![sigma_Delta_x](.eqs/sigma_Delta_x.png) от `x`;
    * точками изобразите на графике `ccd.png` зависимость ![sigma_Delta_x](.eqs/sigma_Delta_x.png) от `x`;
    * используя метод наименьших квадратов (функцию `lstsq`, реализованную в предыдущем упражнении), получите оценку двух коэффициентов линейной зависимости;
    * изобразите прямой линией на том же графике `ccd.png` модельную зависимость ![sigma_Delta_x](.eqs/sigma_Delta_x.png) от `x`;
    * используя полученные оценки коэффициентов линейной зависимости, получите оценки значений величин _коэффициента усиления_ `g` и _шума считывания_ ![sigma_r](.eqs/sigma_r.png);
    * используя формулу оценки погрешности в косвенных измерениях, оцените ошибки определения _коэффициента усиления_ `g` и _шума считывания_ ![sigma_r](.eqs/sigma_r.png);
    * результат сохраните в файле `ccd.json` в следующем формате:
    ```
    {
        "ron": 12.34,
        "ron_err": 0.12,
        "gain": 1.234,
        "gain_err": 0.0012
    }
    ```

